var verts = {
  0:  -0.5,
  1:  -0.5,
  2:  -0.5,
  
  3:  0.5,
  4:  -0.5,
  5:  -0.5,
  
  6:  0.5,
  7:  -0.5,
  8:  0.5,
  
  9:   -0.5,
  10:  -0.5,
  11:  0.5,
  
  12:  -0.5,
  13:  0.5,
  14:  -0.5,
  
  15:  0.5,
  16:  0.5,
  17:  -0.5,
  
  18:  0.5,
  19:  0.5,
  20:  0.5,
  
  21:  -0.5,
  22:  0.5,
  23:  0.5,
  
};
var edges = {
  0: 0,
  1: 1,
  2: 1,
  3: 2,
  4: 2,
  5: 3,
  6: 3,
  7: 0,
  8: 0,
  9: 4,
  10: 4,
  11: 5,
  12: 5,
  13: 6,
  14: 6,
  15: 7,
  16: 7,
  17: 4,
  18: 7,
  19: 3,
  20: 1,
  21: 5,
  22: 2,
  23: 6,
  24: 6,
  25: 2
};
var rotMatrixX = {
  0: 1,
  1: 0,
  2: 0,
  3: 0,
  4: 3,
  5: -2,
  6: 0,
  7: 2,
  8: 3
};
var rotMatrixY = {
  0: 3,
  1: 0,
  2: 2,
  3: 0,
  4: 1,
  5: 0,
  6: -2,
  7: 0,
  8: 3
};
var rotMatrixZ = {
  0: 3,
  1: -2,
  2: 0,
  3: 2,
  4: 3,
  5: 0,
  6: 0,
  7: 0,
  8: 1
};
var matrices = {
  0:rotMatrixY,
  1:rotMatrixX,
  2:rotMatrixZ
};
var transform = {};
var screenSpc = {};
createCanvas("screen", 320, 320);
var clipPlane = 0.1;
var FOV = 0.1;
var camPos = {0:0,1:-1};
var euler = {0:0,1:0,2:0};
var x=0;
var y=0;
var z=0;
var i = 0;
var d = 0;
function gc(){
  x = 0;
  y = 0;
  z = 0;
  i = 0;
  d = 0;
  //console.clear();
  
  
  var verts2 = {};
  var verts3 = {};
  //transform verts, linearly and angularly around cam transform
  for (i; i < 8; i++)
  {
    for (d; d < 3; d++)
    {
        verts2[d] = verts[i*3 + d];
        verts3[d] = verts[i*3 + d];
    }
    d = 0 ;
    
    
    //x = (x * Math.cos(deg))+(z*Math.sin(deg));
    //z = (-x * Math.sin(deg))+(z*Math.cos(deg));
    verts3[0] += -camPos[0]; //* Math.cos(deg)+camPos[1]*Math.sin(deg); 
    
    verts3[2] += -camPos[1]; //* Math.cos(deg)+-camPos[0]*Math.sin(deg);
    for (var f = 0; f < 3; f++)
    {
      var deg = euler[f];
      
      for (var j = 0; j < 3; j++)
      {
        var finalval = 0;
        for (var l = 0; l < 3; l++)
        {
          var val = matrices[f][j*3+l];
          
          if (Math.abs(val) == 2)
          {
            finalval += verts3[l]*(Math.sin(deg)*(val/2));
          }
          else if (Math.abs(val) == 3)
          {
            finalval += verts3[l]*(Math.cos(deg)*(val/3));
          }
          else
          {
            finalval += verts3[l]*val;
          }
        }
        verts2[j] = finalval;
      }
      verts3[0] = verts2[0];
      verts3[1] = verts2[1];
      verts3[2] = verts2[2];
      
      
      
    }
    
    //console.log(verts2);
    
    FOV =  0.1 -(getProperty("fovSlider","value")-100)/100;
    x = verts2[0];
    y = verts2[1];
    z = verts2[2];
    
    //convert to screen space
    if (z <=clipPlane)
    {
      screenSpc[i*2] = null;
      screenSpc[i*2+1] = null;
    }
    else
    {
      var clipPos = (clipPlane/z);
      x = x*clipPos;
      y = y*clipPos;
      var xfac = 0.5 + (x/FOV)/2;
      var yfac = 0.5 + (y/FOV)/2;
      screenSpc[i*2] = 320*xfac;
      screenSpc[i*2+1] = 320*yfac;
    }
    
  }
  i = 0;
  
  
}
function render()
{
  clearCanvas();
  rect(0, 0, 320, 320);
  for (i; i < 12; i++)
  {
    var x1 = screenSpc[edges[i*2]*2];
    var y1 = screenSpc[edges[i*2]*2+1];
    var x2 = screenSpc[edges[i*2+1]*2];
    var y2 = screenSpc[edges[i*2+1]*2+1];
    if (x1!=null && y1!=null&&x2!=null&&y2!=null)
    {
      //circle(x1, y1, 10);
      line(x1,y1,x2,y2);
    }
    
  }
}
timedLoop(100, function() {
  
    gc();
    render();
  
  
});

onEvent("screen1", "keypress",function(event){
  //console.clear();
  //console.log(event.key);
  var deg = (getProperty("rotSlider2","value")-50)/25;
  var forward=0;
  var right=0;
  if (event.key == "w")
  {
    forward+=0.1;
  }
  if (event.key == "s")
  {
    forward-=0.1;
  }
  if (event.key == "a")
  {
    right-=0.1;
  }
  if (event.key == "d")
  {
    right+=0.1;
  }
  
  if (event.key == "j")
  {
    euler[0] +=0.1;
  }
  if (event.key == "l")
  {
    euler[0] +=-0.1;
  }
  if (event.key == "k")
  {
    euler[1] +=0.1;
  }
  if (event.key == "i")
  {
    euler[1] -=0.1;
  }
  camPos[0] += right*Math.cos(-euler[0])+forward*Math.sin(-euler[0]);
  camPos[1] += forward*Math.cos(-euler[0])-right*Math.sin(-euler[0]);
});

